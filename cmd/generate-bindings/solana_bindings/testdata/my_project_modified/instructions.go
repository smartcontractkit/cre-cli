// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions.

package my_project

import (
	"bytes"
	"fmt"
	"context"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
	rpc "github.com/gagliardetto/solana-go/rpc"
	"github.com/smartcontractkit/cre-cli/cmd/generate-bindings/solana_bindings/cre-sdk-go/common"

)

// Builds a "get_input_data" instruction.
func NewGetInputDataInstruction(
	inputParam string,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_GetInputData[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `inputParam`:
		err = enc__.Encode(inputParam)
		if err != nil {
			return nil, errors.NewField("inputParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "get_input_data_from_account" instruction.
func NewGetInputDataFromAccountInstruction(
	// Params:
	inputParam string,

	// Accounts:
	dataAccountAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_GetInputDataFromAccount[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `inputParam`:
		err = enc__.Encode(inputParam)
		if err != nil {
			return nil, errors.NewField("inputParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "data_account": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(dataAccountAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize" instruction.
func NewInitializeInstruction(
	// Params:
	inputParam string,

	// Accounts:
	dataAccountAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `inputParam`:
		err = enc__.Encode(inputParam)
		if err != nil {
			return nil, errors.NewField("inputParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "data_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(dataAccountAccount, true, false))
		// Account 1 "user": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_data" instruction.
func NewUpdateDataInstruction(
	input UpdateDataInput,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateData[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newDataParam`:
		err = enc__.Encode(input.newDataParam)
		if err != nil {
			return nil, errors.NewField("newDataParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "data_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(input.dataAccountAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_data_with_typed_return" instruction.
func NewUpdateDataWithTypedReturnInstruction(
	// Params:
	newDataParam string,

	// Accounts:
	dataAccountAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateDataWithTypedReturn[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newDataParam`:
		err = enc__.Encode(newDataParam)
		if err != nil {
			return nil, errors.NewField("newDataParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "data_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(dataAccountAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}


// Builds a "update_data" instruction.
func SendUpdateDataInstruction(
	// Params:
	newDataParam string,

	// Accounts:
	dataAccountAccount solanago.PublicKey,

	// type this into a struct
	solanaClient *rpc.Client,
	signer solanago.PrivateKey,
	commitment rpc.CommitmentType,
	opts ...common.TxModifier,
) (string, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateData[:], false)
	if err != nil {
		return "", fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newDataParam`:
		err = enc__.Encode(newDataParam)
		if err != nil {
			return "", errors.NewField("newDataParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "data_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(dataAccountAccount, true, false))
	}

	// Create the instruction.
	ix := solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	)
	res, err := common.SendAndConfirm(context.Background(), solanaClient, []solanago.Instruction{ix}, signer, commitment, opts...)
	if err != nil {
		return "", err
	}
	return DecodeUpdateDataInstructionOutput(res.Meta.LogMessages)
}

func DecodeUpdateDataInstructionOutput(logs []string) (string, error) {
	output, err := common.ExtractTypedReturnValue(context.Background(), logs, ProgramID.String(), func(b []byte) string {
		return string(b[4:])
	})
	if err != nil {
		return "", err
	}
	return output, nil
}

func SendUpdateDataWithTypedReturnInstruction(
	// Params:
	newDataParam string,

	// Accounts:
	dataAccountAccount solanago.PublicKey,
	

	// type this into a struct
	solanaClient *rpc.Client,
	signer solanago.PrivateKey,
	commitment rpc.CommitmentType,
	opts ...common.TxModifier,
) (UpdateResponse, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateDataWithTypedReturn[:], false)
	if err != nil {
		return UpdateResponse{}, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newDataParam`:
		err = enc__.Encode(newDataParam)
		if err != nil {
			return UpdateResponse{}, errors.NewField("newDataParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "data_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(dataAccountAccount, true, false))
	}

	// Create the instruction.
	ix := solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	)
	res, err := common.SendAndConfirm(context.Background(), solanaClient, []solanago.Instruction{ix}, signer, commitment, opts...)
	if err != nil {
		return UpdateResponse{}, err
	}
	return DecodeUpdateDataWithTypedReturnInstructionOutput(res.Meta.LogMessages)
}

func DecodeUpdateDataWithTypedReturnInstructionOutput(logs []string) (UpdateResponse, error) {
	output, err := common.ExtractAnchorTypedReturnValue[UpdateResponse](context.Background(), logs, ProgramID.String())
	if err != nil {
		return UpdateResponse{}, err
	}
	return *output, nil
}

func WriteReportFromSendUpdateDataInstruction(
	runtime cre.Runtime,
	// should we type struct the inputs ? should this be made into UpdateDataInput ?
	newDataParam string,
	// Accounts:
	dataAccountAccount solanago.PublicKey,
) cre.Promise[*solana.WriteReportReply] {

	ix, _ := NewUpdateDataInstruction(newDataParam, dataAccountAccount)
	
	promise := runtime.GenerateReport(&pb2.ReportRequest{
		EncodedPayload: ix.Data(),
		EncodedAccounts: ix.Accounts(), // this needs to be added
		EncoderName:    "solana",
		SigningAlgo:    "blah",
		HashingAlgo:    "blah",
	})

	return cre.ThenPromise(promise, func(report *cre.Report) cre.Promise[*solana.WriteReportReply] {
		return c.client.WriteReport(runtime, &solana.WriteCreReportRequest{
			Receiver:  ProgramID.Bytes(),
			Report:    report,
		})
	})
}

type UpdateDataInput struct {
	newDataParam string
	dataAccountAccount solanago.PublicKey
}

func WriteReportFromSendUpdateDataInstruction(
	runtime cre.Runtime,
	input UpdateDataInput,
) cre.Promise[*solana.WriteReportReply] {

	ix, _ := NewUpdateDataInstruction(input)
	
	promise := runtime.GenerateReport(&pb2.ReportRequest{
		EncodedPayload: ix.Data(),
		EncodedAccounts: ix.Accounts(), // this needs to be added
		EncoderName:    "solana",
		SigningAlgo:    "blah",
		HashingAlgo:    "blah",
	})

	return cre.ThenPromise(promise, func(report *cre.Report) cre.Promise[*solana.WriteReportReply] {
		return c.client.WriteReport(runtime, &solana.WriteCreReportRequest{
			Receiver:  ProgramID.Bytes(),
			Report:    report,
		})
	})
}