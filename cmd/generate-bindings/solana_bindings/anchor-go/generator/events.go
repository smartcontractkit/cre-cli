package generator

import (
	"fmt"

	"github.com/dave/jennifer/jen"
	. "github.com/dave/jennifer/jen"
	"github.com/gagliardetto/anchor-go/tools"
)

func (g *Generator) genfile_events() (*OutputFile, error) {
	file := NewFile(g.options.Package)
	file.HeaderComment("Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.")
	file.HeaderComment("This file contains parsers for the events defined in the IDL.")

	names := []string{}
	{
		for _, event := range g.idl.Events {
			names = append(names, tools.ToCamelUpper(event.Name))
		}
	}
	{
		code, err := g.gen_eventParser(names)
		if err != nil {
			return nil, fmt.Errorf("error generating event parser: %w", err)
		}
		file.Add(code)
	}

	return &OutputFile{
		Name: "events.go",
		File: file,
	}, nil
}

func (g *Generator) gen_eventParser(eventNames []string) (Code, error) {
	code := Empty()
	{
		code.Func().Id("ParseAnyEvent").
			Params(Id("eventData").Index().Byte()).
			Params(Any(), Error()).
			BlockFunc(func(block *Group) {
				block.Id("decoder").Op(":=").Qual(PkgBinary, "NewBorshDecoder").Call(Id("eventData"))
				block.List(Id("discriminator"), Err()).Op(":=").Id("decoder").Dot("ReadDiscriminator").Call()

				block.If(Err().Op("!=").Nil()).Block(
					Return(
						Nil(),
						Qual("fmt", "Errorf").Call(Lit("failed to peek event discriminator: %w"), Err()),
					),
				)

				block.Switch(Id("discriminator")).BlockFunc(func(switchBlock *Group) {
					for _, name := range eventNames {
						switchBlock.Case(Id(FormatEventDiscriminatorName(name))).Block(
							Id("value").Op(":=").New(Id(name)),
							Err().Op(":=").Id("value").Dot("UnmarshalWithDecoder").Call(Id("decoder")),
							If(Err().Op("!=").Nil()).Block(
								Return(
									Nil(),
									Qual("fmt", "Errorf").Call(Lit("failed to unmarshal event as "+name+": %w"), Err()),
								),
							),
							Return(Id("value"), Nil()),
						)
					}
					switchBlock.Default().Block(
						Return(Nil(), Qual("fmt", "Errorf").Call(Lit("unknown discriminator: %s"), Qual(PkgBinary, "FormatDiscriminator").Call(Id("discriminator")))),
					)
				})
			})
	}
	{
		code.Line().Line()
		// for each event, generate a function to parse it:
		for _, name := range eventNames {
			discriminatorName := FormatEventDiscriminatorName(name)

			code.Func().Id("ParseEvent_"+name).
				Params(Id("eventData").Index().Byte()).
				Params(Op("*").Id(name), Error()).
				BlockFunc(func(block *Group) {
					block.Id("decoder").Op(":=").Qual(PkgBinary, "NewBorshDecoder").Call(Id("eventData"))
					block.List(Id("discriminator"), Err()).Op(":=").Id("decoder").Dot("ReadDiscriminator").Call()

					block.If(Err().Op("!=").Nil()).Block(
						Return(
							Nil(),
							Qual("fmt", "Errorf").Call(Lit("failed to peek discriminator: %w"), Err()),
						),
					)

					block.If(Id("discriminator").Op("!=").Id(discriminatorName)).Block(
						Return(Nil(), Qual("fmt", "Errorf").Call(Lit("expected discriminator %v, got %s"), Id(discriminatorName), Qual(PkgBinary, "FormatDiscriminator").Call(Id("discriminator")))),
					)

					block.Id("event").Op(":=").New(Id(name))
					block.Err().Op("=").Id("event").Dot("UnmarshalWithDecoder").Call(Id("decoder"))

					block.If(Err().Op("!=").Nil()).Block(
						Return(
							Nil(),
							Qual("fmt", "Errorf").Call(Lit("failed to unmarshal event of type "+name+": %w"), Err()),
						),
					)

					block.Return(Id("event"), Nil())
				})
			code.Line().Line()

			code.Func().Id("DecodeEvent_"+name).
				Params(Id("event").Qual(PkgSolanaTypes, "Log")).
				Params(Op("*").Id(name), Error()).
				BlockFunc(func(block *Group) {
					block.List(Id("res"), Id("err")).Op(":=").Id("ParseEvent_" + name).Call(
						Id("event").Dot("Data"),
					)
					block.If(Id("err").Op("!=").Nil()).Block(
						Return(Nil(), Id("err")),
					)
					block.Return(Id("res"), Nil())
				})
			code.Line().Line()

			code.Type().Id(name + "Trigger").
				Struct(
					Qual(PkgCRE, "Trigger"). // embedded generic type
									Types(
							Op("*").Qual(PkgSolanaCre, "Log"),
							Op("*").Qual(PkgSolanaCre, "Log"),
						),
				)
			code.Line().Line()

			code.Func().
				Params(Id("t").Op("*").Id(name+"Trigger")). // receiver (*DataUpdatedTrigger)
				Id("Adapt").
				Params(
					Id("l").Op("*").Qual(PkgSolanaCre, "Log"),
				).
				Params(
					Op("*").Qual(PkgBindings, "DecodedLog").Types(Id(name)), // return type
					Error(),
				).
				Block(
					List(Id("decoded"), Id("err")).Op(":=").Id("DecodeEvent_"+name).Call(Id("l")),
					If(Id("err").Op("!=").Nil()).Block(
						Return(Nil(), Id("err")),
					),
					Return(
						Op("&").Qual(PkgBindings, "DecodedLog").Types(Id(name)).Values(Dict{
							Id("Log"):  Id("l"),
							Id("Data"): Op("*").Id("decoded"),
						}),
						Nil(),
					),
				)
			code.Line().Line()

			code.Func().
				Params(Id("c").Op("*").Id("MyProject")). // method receiver
				Id("LogTrigger_"+name).
				Params(
					Id("chainSelector").Uint64(),
					Id("subKeyPathAndValue").Index().Qual(PkgSolanaCre, "SubKeyPathAndFilter"),
				).
				Params(
					Qual(PkgCRE, "Trigger").Types(
						Op("*").Qual(PkgSolanaCre, "Log"),
						Op("*").Qual(PkgBindings, "DecodedLog").Types(Id(name)),
					),
					Error(),
				).
				BlockFunc(func(b *jen.Group) {
					// if len(subKeyPathAndValue) > 4 { return nil, fmt.Errorf(...) }
					b.If(Len(Id("subKeyPathAndValue")).Op(">").Lit(4)).Block(
						Return(
							Nil(),
							Qual("fmt", "Errorf").Call(
								Lit("too many subkey path and value pairs: %d"),
								Len(Id("subKeyPathAndValue")),
							),
						),
					)

					// subKeyPaths, subKeyFilters, err := bindings.ValidateSubKeyPathAndValueExactNoPtr[<Event>](subKeyPathAndValue)
					b.List(
						Id("subKeyPaths"),
						Id("subKeyFilters"),
						Id("err"),
					).Op(":=").Qual(PkgBindings, "ValidateSubKeyPathAndValueExactNoPtr").
						Types(Id(name)).
						Call(Id("subKeyPathAndValue"))

					b.If(Id("err").Op("!=").Nil()).Block(
						Return(
							Nil(),
							Qual("fmt", "Errorf").Call(
								Lit("failed to validate subkey path and value: %w"),
								Id("err"),
							),
						),
					)

					// eventIdl := types.GetIdlEvent(c.IdlTypes, "<Event>")
					b.Id("eventIdl").Op(":=").Qual(PkgSolanaTypes, "GetIdlEvent").Call(
						Id("c").Dot("IdlTypes"),
						Lit(name),
					)

					// rawTrigger := solana.LogTrigger(chainSelector, &solana.FilterLogTriggerRequest{ ... })
					b.Id("rawTrigger").Op(":=").Qual(PkgSolanaCre, "LogTrigger").Call(
						Id("chainSelector"),
						Op("&").Qual(PkgSolanaCre, "FilterLogTriggerRequest").Values(jen.Dict{
							Id("Address"):       Qual(PkgSolanaTypes, "PublicKey").Call(Id("ProgramID")),
							Id("EventName"):     Lit(name),
							Id("EventSig"):      Id("Event_" + name),
							Id("EventIdl"):      Id("eventIdl"),
							Id("SubkeyPaths"):   Id("subKeyPaths"),
							Id("SubkeyFilters"): Id("subKeyFilters"),
						}),
					)

					// return &<Event>Trigger{ Trigger: rawTrigger }, nil
					b.Return(
						Op("&").Id(name+"Trigger").Values(jen.Dict{
							Id("Trigger"): Id("rawTrigger"),
						}),
						Nil(),
					)
				})
			code.Line().Line()
		}
	}
	return code, nil
}

/*
type LogTriggerConfig struct {
	Name          string
	Address       lptypes.PublicKey
	EventName     string
	EventSig      lptypes.EventSignature
	StartingBlock int64
	EventIdl      lptypes.EventIdl
	SubkeyPaths   [][]string
	Retention     time.Duration
	MaxLogsKept   int64
	SubkeyFilters []SubkeyFilterCriteria
}

type SubkeyFilterCriteria struct {
	SubkeyIndex uint64
	Comparers   []primitives.ValueComparator
}

*/
