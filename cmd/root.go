package cmd

import (
	_ "embed"
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/charmbracelet/huh"
	"github.com/rs/zerolog"
	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
	"github.com/spf13/viper"

	"github.com/smartcontractkit/cre-cli/cmd/account"
	"github.com/smartcontractkit/cre-cli/cmd/client"
	"github.com/smartcontractkit/cre-cli/cmd/creinit"
	generatebindings "github.com/smartcontractkit/cre-cli/cmd/generate-bindings"
	"github.com/smartcontractkit/cre-cli/cmd/login"
	"github.com/smartcontractkit/cre-cli/cmd/logout"
	"github.com/smartcontractkit/cre-cli/cmd/secrets"
	"github.com/smartcontractkit/cre-cli/cmd/update"
	"github.com/smartcontractkit/cre-cli/cmd/version"
	"github.com/smartcontractkit/cre-cli/cmd/whoami"
	"github.com/smartcontractkit/cre-cli/cmd/workflow"
	"github.com/smartcontractkit/cre-cli/internal/constants"
	"github.com/smartcontractkit/cre-cli/internal/context"
	"github.com/smartcontractkit/cre-cli/internal/logger"
	"github.com/smartcontractkit/cre-cli/internal/runtime"
	"github.com/smartcontractkit/cre-cli/internal/settings"
	"github.com/smartcontractkit/cre-cli/internal/telemetry"
	"github.com/smartcontractkit/cre-cli/internal/ui"
	intupdate "github.com/smartcontractkit/cre-cli/internal/update"
)

//go:embed template/help_template.tpl
var helpTemplate string

var (
	// RootCmd represents the base command when called without any subcommands
	RootCmd = newRootCommand()

	runtimeContextForTelemetry *runtime.Context
	executingCommand           *cobra.Command
	executingArgs              []string
)

func Execute() {
	err := RootCmd.Execute()

	exitCode := 0
	if err != nil {
		ui.Error(err.Error())
		exitCode = 1
	}

	if executingCommand != nil && runtimeContextForTelemetry != nil {
		telemetry.EmitCommandEvent(executingCommand, executingArgs, exitCode, runtimeContextForTelemetry, err)
		time.Sleep(200 * time.Millisecond)
	}

	os.Exit(exitCode)
}

func newRootCommand() *cobra.Command {
	rootLogger := createLogger()
	rootViper := createViper()
	runtimeContext := runtime.NewContext(rootLogger, rootViper)

	runtimeContextForTelemetry = runtimeContext

	// By defining a Run func, we force PersistentPreRunE to execute
	// even when 'cre', 'workflow', etc is called with no subcommand
	// this enables to check for update and display if needed
	helpRunE := func(cmd *cobra.Command, args []string) error {
		err := cmd.Help()
		if err != nil {
			return fmt.Errorf("fail to show help: %w", err)
		}
		return nil
	}

	rootCmd := &cobra.Command{
		Use:   "cre",
		Short: "CRE CLI tool",
		Long:  `A command line tool for building, testing and managing Chainlink Runtime Environment (CRE) workflows.`,
		// remove autogenerated string that contains this comment: "Auto generated by spf13/cobra on DD-Mon-YYYY"
		// timestamps can cause docs to keep regenerating on each new PR for no good reason
		DisableAutoGenTag: true,
		// Silence Cobra's default error display - we use styled ui.Error() instead
		SilenceErrors: true,
		// this will be inherited by all submodules and all their commands

		RunE: helpRunE,

		PersistentPreRunE: func(cmd *cobra.Command, args []string) error {
			// Silence usage for runtime errors - at this point flag parsing succeeded,
			// so any errors from here are runtime errors, not usage errors
			cmd.SilenceUsage = true

			executingCommand = cmd
			executingArgs = args

			log := runtimeContext.Logger
			v := runtimeContext.Viper

			// Start the global spinner for commands that do initialization work
			spinner := ui.GlobalSpinner()
			showSpinner := shouldShowSpinner(cmd)
			if showSpinner {
				spinner.Start("Initializing...")
			}

			// add binding for all existing command flags via Viper
			// this step has to run first because flags have higher precedence over configuration parameters and defaults values
			if err := v.BindPFlags(cmd.Flags()); err != nil {
				if showSpinner {
					spinner.Stop()
				}
				return fmt.Errorf("failed to bind flags: %w", err)
			}

			// Update log level if verbose flag is set
			if verbose := v.GetBool(settings.Flags.Verbose.Name); verbose {
				newLogger := log.Level(zerolog.DebugLevel)
				if _, found := os.LookupEnv("SETH_LOG_LEVEL"); !found {
					os.Setenv("SETH_LOG_LEVEL", "debug")
				}
				runtimeContext.Logger = &newLogger
				runtimeContext.ClientFactory = client.NewFactory(&newLogger, v)
			}

			if showSpinner {
				spinner.Update("Loading environment...")
			}
			err := runtimeContext.AttachEnvironmentSet()
			if err != nil {
				if showSpinner {
					spinner.Stop()
				}
				return fmt.Errorf("failed to load environment details: %w", err)
			}

			if isLoadCredentials(cmd) {
				if showSpinner {
					spinner.Update("Validating credentials...")
				}
				skipValidation := shouldSkipValidation(cmd)
				err := runtimeContext.AttachCredentials(cmd.Context(), skipValidation)
				if err != nil {
					if showSpinner {
						spinner.Stop()
					}

					// Prompt user to login
					ui.Line()
					ui.Warning("You are not logged in")
					ui.Line()

					var runLogin bool
					confirmForm := huh.NewForm(
						huh.NewGroup(
							huh.NewConfirm().
								Title("Would you like to login now?").
								Affirmative("Yes, login").
								Negative("No, cancel").
								Value(&runLogin),
						),
					).WithTheme(ui.ChainlinkTheme())

					if formErr := confirmForm.Run(); formErr != nil {
						return fmt.Errorf("authentication required: %w", err)
					}

					if !runLogin {
						return fmt.Errorf("authentication required: %w", err)
					}

					// Run login flow
					ui.Line()
					if loginErr := login.Run(runtimeContext); loginErr != nil {
						return fmt.Errorf("login failed: %w", loginErr)
					}

					// Exit after successful login - user can re-run their command
					os.Exit(0)
				}

				// Check if organization is ungated for commands that require it
				cmdPath := cmd.CommandPath()
				if cmdPath == "cre account link-key" || cmdPath == "cre workflow deploy" {
					if err := runtimeContext.Credentials.CheckIsUngatedOrganization(); err != nil {
						if showSpinner {
							spinner.Stop()
						}
						return err
					}
				}
			}

			// load settings from yaml files
			if isLoadSettings(cmd) {
				if showSpinner {
					spinner.Update("Loading settings...")
				}
				// Set execution context (project root + workflow directory if applicable)
				projectRootFlag := runtimeContext.Viper.GetString(settings.Flags.ProjectRoot.Name)
				if err := context.SetExecutionContext(cmd, args, projectRootFlag, rootLogger); err != nil {
					if showSpinner {
						spinner.Stop()
					}
					return err
				}

				err := runtimeContext.AttachSettings(cmd, isLoadDeploymentRPC(cmd))
				if err != nil {
					if showSpinner {
						spinner.Stop()
					}
					return fmt.Errorf("%w", err)
				}
			}

			// Stop the initialization spinner - commands can start their own if needed
			if showSpinner {
				spinner.Stop()
			}

			return nil
		},

		PersistentPostRun: func(cmd *cobra.Command, args []string) {

			// Check for updates *sequentially* after the main command has run.
			// This guarantees it prints at the end, after all other output.
			if shouldCheckForUpdates(cmd) {
				intupdate.CheckForUpdates(version.Version, runtimeContext.Logger)
			}
		},
	}

	cobra.AddTemplateFunc("wrappedFlagUsages", func(fs *pflag.FlagSet) string {
		// 100 = wrap width
		return strings.TrimRight(fs.FlagUsagesWrapped(100), "\n")
	})

	cobra.AddTemplateFunc("hasUngrouped", func(c *cobra.Command) bool {
		for _, cmd := range c.Commands() {
			if cmd.IsAvailableCommand() && !cmd.Hidden && cmd.GroupID == "" {
				return true
			}
		}
		return false
	})

	// Lipgloss-styled template functions for help (using Chainlink brand colors)
	cobra.AddTemplateFunc("styleTitle", func(s string) string {
		return ui.TitleStyle.Render(s)
	})
	cobra.AddTemplateFunc("styleSection", func(s string) string {
		return ui.TitleStyle.Render(s)
	})
	cobra.AddTemplateFunc("styleCommand", func(s string) string {
		return ui.CommandStyle.Render(s) // Light Blue - prominent
	})
	cobra.AddTemplateFunc("styleDim", func(s string) string {
		return ui.DimStyle.Render(s) // Gray - less important
	})
	cobra.AddTemplateFunc("styleSuccess", func(s string) string {
		return ui.SuccessStyle.Render(s) // Green
	})
	cobra.AddTemplateFunc("styleCode", func(s string) string {
		return ui.CodeStyle.Render(s) // Light Blue - visible
	})
	cobra.AddTemplateFunc("styleURL", func(s string) string {
		return ui.URLStyle.Render(s) // Chainlink Blue, underlined
	})

	rootCmd.SetHelpTemplate(helpTemplate)

	// Definition of global flags:
	// env file flag is present for every subcommand
	rootCmd.PersistentFlags().StringP(
		settings.Flags.CliEnvFile.Name,
		settings.Flags.CliEnvFile.Short,
		constants.DefaultEnvFileName,
		fmt.Sprintf("Path to %s file which contains sensitive info", constants.DefaultEnvFileName),
	)
	// project root path flag is present for every subcommand
	rootCmd.PersistentFlags().StringP(
		settings.Flags.ProjectRoot.Name,
		settings.Flags.ProjectRoot.Short,
		"",
		"Path to the project root",
	)
	// verbose flag is present in every subcommand
	rootCmd.PersistentFlags().BoolP(
		settings.Flags.Verbose.Name,
		settings.Flags.Verbose.Short,
		false,
		"Run command in VERBOSE mode",
	)
	// target settings is present in every subcommand
	rootCmd.PersistentFlags().StringP(
		settings.Flags.Target.Name,
		settings.Flags.Target.Short,
		"",
		"Use target settings from YAML config",
	)
	rootCmd.CompletionOptions.HiddenDefaultCmd = true

	secretsCmd := secrets.New(runtimeContext)
	workflowCmd := workflow.New(runtimeContext)
	versionCmd := version.New(runtimeContext)
	loginCmd := login.New(runtimeContext)
	logoutCmd := logout.New(runtimeContext)
	initCmd := creinit.New(runtimeContext)
	genBindingsCmd := generatebindings.New(runtimeContext)
	accountCmd := account.New(runtimeContext)
	whoamiCmd := whoami.New(runtimeContext)
	updateCmd := update.New(runtimeContext)

	secretsCmd.RunE = helpRunE
	workflowCmd.RunE = helpRunE
	accountCmd.RunE = helpRunE

	// Define groups (order controls display order)
	rootCmd.AddGroup(&cobra.Group{ID: "getting-started", Title: "Getting Started"})
	rootCmd.AddGroup(&cobra.Group{ID: "account", Title: "Account"})
	rootCmd.AddGroup(&cobra.Group{ID: "workflow", Title: "Workflow"})
	rootCmd.AddGroup(&cobra.Group{ID: "secret", Title: "Secret"})

	initCmd.GroupID = "getting-started"

	loginCmd.GroupID = "account"
	logoutCmd.GroupID = "account"
	accountCmd.GroupID = "account"
	whoamiCmd.GroupID = "account"

	secretsCmd.GroupID = "secret"
	workflowCmd.GroupID = "workflow"

	rootCmd.AddCommand(
		initCmd,
		versionCmd,
		loginCmd,
		logoutCmd,
		accountCmd,
		whoamiCmd,
		secretsCmd,
		workflowCmd,
		genBindingsCmd,
		updateCmd,
	)

	return rootCmd
}

func isLoadSettings(cmd *cobra.Command) bool {
	// It is not expected to have the settings file when running the following commands
	var excludedCommands = map[string]struct{}{
		"cre version":               {},
		"cre login":                 {},
		"cre logout":                {},
		"cre whoami":                {},
		"cre account list-key":      {},
		"cre init":                  {},
		"cre generate-bindings":     {},
		"cre completion bash":       {},
		"cre completion fish":       {},
		"cre completion powershell": {},
		"cre completion zsh":        {},
		"cre help":                  {},
		"cre update":                {},
		"cre workflow":              {},
		"cre account":               {},
		"cre secrets":               {},
		"cre":                       {},
	}

	_, exists := excludedCommands[cmd.CommandPath()]
	return !exists
}

func isLoadCredentials(cmd *cobra.Command) bool {
	// It is not expected to have the credentials loaded when running the following commands
	var excludedCommands = map[string]struct{}{
		"cre version":               {},
		"cre login":                 {},
		"cre completion bash":       {},
		"cre completion fish":       {},
		"cre completion powershell": {},
		"cre completion zsh":        {},
		"cre help":                  {},
		"cre generate-bindings":     {},
		"cre update":                {},
		"cre workflow":              {},
		"cre account":               {},
		"cre secrets":               {},
		"cre":                       {},
	}

	_, exists := excludedCommands[cmd.CommandPath()]
	return !exists
}

func isLoadDeploymentRPC(cmd *cobra.Command) bool {
	var includedCommands = map[string]struct{}{
		"cre workflow deploy":    {},
		"cre workflow pause":     {},
		"cre workflow activate":  {},
		"cre workflow delete":    {},
		"cre account link-key":   {},
		"cre account unlink-key": {},
		"cre secrets create":     {},
		"cre secrets delete":     {},
		"cre secrets execute":    {},
		"cre secrets list":       {},
		"cre secrets update":     {},
	}
	_, exists := includedCommands[cmd.CommandPath()]
	return exists
}

func shouldSkipValidation(cmd *cobra.Command) bool {
	var excludedCommands = map[string]struct{}{
		"cre logout": {},
	}

	_, exists := excludedCommands[cmd.CommandPath()]
	return exists
}

func shouldCheckForUpdates(cmd *cobra.Command) bool {
	var excludedCommands = map[string]struct{}{
		"bash":       {},
		"zsh":        {},
		"fish":       {},
		"powershell": {},
		"update":     {},
	}

	_, exists := excludedCommands[cmd.Name()]
	return !exists
}

func shouldShowSpinner(cmd *cobra.Command) bool {
	// Don't show spinner for commands that don't do async work
	// or commands that have their own interactive UI (like init)
	var excludedCommands = map[string]struct{}{
		"cre":                       {},
		"cre version":               {},
		"cre help":                  {},
		"cre completion bash":       {},
		"cre completion fish":       {},
		"cre completion powershell": {},
		"cre completion zsh":        {},
		"cre init":                  {}, // Has its own Huh forms UI
		"cre login":                 {}, // Has its own interactive flow
		"cre logout":                {},
		"cre update":                {},
		"cre workflow":              {}, // Just shows help
		"cre account":               {}, // Just shows help
		"cre secrets":               {}, // Just shows help
	}

	_, exists := excludedCommands[cmd.CommandPath()]
	return !exists
}

func createLogger() *zerolog.Logger {
	// Set default Seth log level if not set
	if _, found := os.LookupEnv("SETH_LOG_LEVEL"); !found {
		os.Setenv("SETH_LOG_LEVEL", constants.DefaultSethLogLevel)
	}

	return logger.NewConsoleLogger()
}

func createViper() *viper.Viper {
	return viper.New() //nolint:forbidigo
}
