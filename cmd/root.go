package cmd

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/rs/zerolog"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"

	"github.com/smartcontractkit/dev-platform/cmd/account"
	"github.com/smartcontractkit/dev-platform/cmd/client"
	"github.com/smartcontractkit/dev-platform/cmd/creinit"
	generatebindings "github.com/smartcontractkit/dev-platform/cmd/generate-bindings"
	"github.com/smartcontractkit/dev-platform/cmd/login"
	"github.com/smartcontractkit/dev-platform/cmd/logout"
	"github.com/smartcontractkit/dev-platform/cmd/secrets"
	"github.com/smartcontractkit/dev-platform/cmd/version"
	"github.com/smartcontractkit/dev-platform/cmd/whoami"
	"github.com/smartcontractkit/dev-platform/cmd/workflow"
	"github.com/smartcontractkit/dev-platform/internal/constants"
	"github.com/smartcontractkit/dev-platform/internal/logger"
	"github.com/smartcontractkit/dev-platform/internal/runtime"
	"github.com/smartcontractkit/dev-platform/internal/settings"
)

// RootCmd represents the base command when called without any subcommands
var RootCmd = newRootCommand()

func Execute() {
	if err := RootCmd.Execute(); err != nil {
		os.Exit(1)
	}
}

func newRootCommand() *cobra.Command {
	rootLogger := createLogger()
	rootViper := createViper()
	runtimeContext := runtime.NewContext(rootLogger, rootViper)

	rootCmd := &cobra.Command{
		Use:   "cre",
		Short: "Dev Platform CLI tool",
		Long:  `A command line tool for testing and managing CRE workflows.`,
		// remove autogenerated string that contains this comment: "Auto generated by spf13/cobra on DD-Mon-YYYY"
		// timestamps can cause docs to keep regenerating on each new PR for no good reason
		DisableAutoGenTag: true,
		// this will be inherited by all submodules and all their commands

		PersistentPreRunE: func(cmd *cobra.Command, args []string) error {
			log := runtimeContext.Logger
			v := runtimeContext.Viper

			// add binding for all existing command flags via Viper
			// this step has to run first because flags have higher precedence over configuration parameters and defaults values
			if err := v.BindPFlags(cmd.Flags()); err != nil {
				return fmt.Errorf("failed to bind flags: %w", err)
			}

			// Update log level if verbose flag is set
			if verbose := v.GetBool(settings.Flags.Verbose.Name); verbose {
				newLogger := log.Level(zerolog.DebugLevel)
				if _, found := os.LookupEnv("SETH_LOG_LEVEL"); !found {
					os.Setenv("SETH_LOG_LEVEL", "debug")
				}
				runtimeContext.Logger = &newLogger
				runtimeContext.ClientFactory = client.NewFactory(&newLogger, v)
			}

			// load env vars from .env file and configuration parameters from CLI tool config file
			if isLoadEnvAndConfig(cmd) {
				err := runtimeContext.AttachSettings()
				if err != nil {
					return fmt.Errorf("failed to load settings: %w", err)
				}
			}

			err := runtimeContext.AttachCredentials()
			if err != nil {
				return fmt.Errorf("failed to load credentials: %w", err)
			}

			err = runtimeContext.AttachEnvironmentSet()
			if err != nil {
				return fmt.Errorf("failed to load environment details: %w", err)
			}

			return nil
		},
	}

	// Definition of global flags:
	// env file flag is present for every subcommand
	rootCmd.PersistentFlags().StringP(
		settings.Flags.CliEnvFile.Name,
		settings.Flags.CliEnvFile.Short,
		constants.DefaultEnvFileName,
		fmt.Sprintf("Path to %s file which contains sensitive info", constants.DefaultEnvFileName),
	)
	// cli-settings file flag is present for every subcommand
	rootCmd.PersistentFlags().StringP(
		settings.Flags.CliSettingsFile.Name,
		settings.Flags.CliSettingsFile.Short,
		filepath.Join(".", constants.DefaultWorkflowSettingsFileName),
		"Path to CLI workflow settings file",
	)
	// verbose flag is present in every subcommand
	rootCmd.PersistentFlags().BoolP(
		settings.Flags.Verbose.Name,
		settings.Flags.Verbose.Short,
		false,
		"Print DEBUG logs",
	)
	// target settings is present in every subcommand
	rootCmd.PersistentFlags().StringP(
		settings.Flags.Target.Name,
		settings.Flags.Target.Short,
		"",
		"Set the target settings",
	)
	rootCmd.CompletionOptions.HiddenDefaultCmd = true

	rootCmd.AddCommand(secrets.New(runtimeContext))
	rootCmd.AddCommand(workflow.New(runtimeContext))
	rootCmd.AddCommand(version.New(runtimeContext))
	rootCmd.AddCommand(login.New(runtimeContext))
	rootCmd.AddCommand(logout.New(runtimeContext))
	rootCmd.AddCommand(creinit.New(runtimeContext))
	rootCmd.AddCommand(generatebindings.New(runtimeContext))
	rootCmd.AddCommand(account.New(runtimeContext))
	rootCmd.AddCommand(whoami.New(runtimeContext))

	return rootCmd
}

func isLoadEnvAndConfig(cmd *cobra.Command) bool {
	// It is not expected to have the .env and the config file when running the `workflow new` command
	var excludedCommands = map[string]struct{}{
		"version":           {},
		"login":             {},
		"logout":            {},
		"whoami":            {},
		"list-key":          {},
		"init":              {},
		"generate-bindings": {},
		"bash":              {},
		"fish":              {},
		"powershell":        {},
		"zsh":               {},
	}

	_, exists := excludedCommands[cmd.Name()]
	return !exists
}

func createLogger() *zerolog.Logger {
	// Set default Seth log level if not set
	if _, found := os.LookupEnv("SETH_LOG_LEVEL"); !found {
		os.Setenv("SETH_LOG_LEVEL", constants.DefaultSethLogLevel)
	}

	return logger.NewConsoleLogger()
}

func createViper() *viper.Viper {
	return viper.New() //nolint:forbidigo
}
