# Seth will walk through all the files in the directories and load ABIs from them, if they are valid Geth wrappers
# Files that are not geth wrappers will be ignored. Invalid or empty ABIs will cause Seth to fail to initialise
# geth_wrappers_dirs = ["contracts/bind"]

# Uncomment if you want to load (address -> ABI_name) mapping from a file
# It will also save any new contract deployment (address -> ABI_name) mapping there.
# This functionality is not used for simulated networks.
#contract_map_file = "deployed_contracts_mumbai.toml"

# controls which transactions are decoded/traced. Supported values are: none, all, reverted (default).
# if transaction level doesn't match, then calling Decode() does nothing. It's advised to keep it set
# to 'reverted' to limit noise. If you combine it with 'trace_to_json' it will save all possible data
# in JSON files for reverted transactions.
tracing_level = "reverted"

# saves each decoding/tracing results to JSON files; what exactly is saved depends on what we
# were able te decode, we try to save maximum information possible. It can either be:
# just tx hash, decoded transaction or call trace. Which transactions traces are saved depends
# on 'tracing_level'.
# following outputs are possible: dot, json, console
# dot creates DOT graphs for each transaction, json saves decoded transactions and traces to JSON files
trace_outputs = ["console"]

# where to place all artifacts that are generated by Seth, like transaction traces (assuming tracing is enabled and set to files)
artifacts_dir = "artifacts"

# number of addresses to be generated and runtime, if set to 0, no addresses will be generated
# each generated address will receive a proportion of native tokens from root private key's balance
# with the value equal to (root_balance / ephemeral_addresses_number) - transfer_fee * ephemeral_addresses_number
ephemeral_addresses_number = 0

# If enabled we will panic when getting transaction options if current key/address has a pending transaction
# That's because the one we are about to send would get queued, possibly for a very long time. It's best to disable
# it when running load tests.
pending_nonce_protection_enabled = false

# When pending_nonce_protection_enabled is set to true, this value will be used to determine how long we should wait
# for all pending transactions to be mined (so that pending nonce and last nonce are equal).
# pending_nonce_protection_timeout = "10s"

# Amount to be left on root key/address, when we are using ephemeral addresses. It's the amount that will not
# be divided into ephemeral keys.
root_key_funds_buffer = 10 # 10 ether

# feature-flagged expriments; first one sets funds return priority to 'slow' (core only!), second one
# sets the tip/base fee to the higher value in case there's 3+ orders of magnitude difference between them
experiments_enabled = ["slow_funds_return", "eip_1559_fee_equalizer"]

# when enabled when creating a new Seth client we will send 10k wei from root address to root address
# to make sure transaction can be submitted and mined
check_rpc_health_on_start = false

# when enabled, upon creation Seth will validate that there are no private keys set, that node RPC health check is disabled
# and that gas bumping is disabled, since all of these operations are "write" operations. This is useful for running Seth
# only for tracing, when you want to make sure that no transactions are sent to the network.
read_only = false

# when enabled SETH will initialize using HTTP instead of WS
force_http = false

[gas_bumps]
# when > 0 then we will bump gas price for transactions that are stuck in the mempool
# by default the bump step is controlled by gas_price_estimation_tx_priority (check readme.md for more details)
# we bump both contract deployment transactions and any other transaction as long as it's passed to Decode() function
retries = 0
# when > 0 then this will cap the gas price for bumped transactions. Once the cap is reached Seth will stop bumping
# the gas price and will wait for the transaction to be mined.
max_gas_price = 0

[nonce_manager]
key_sync_rate_limit_per_sec = 10
key_sync_timeout = "20s"
key_sync_retry_delay = "1s"
key_sync_retries = 10

[block_stats]
rpc_requests_per_second_limit = 15

[[networks]]
name = "Anvil"
chain_id = 31337
dial_timeout = "1m"
transaction_timeout = "30s"
transfer_gas_fee = 21_000
gas_limit = 10_000_000
# legacy transactions
gas_price = 1_000_000_000
# EIP-1559 transactions
# disabled as it makes some of our tests fail
# eip_1559_dynamic_fees = true
gas_fee_cap = 1_000_000_000
gas_tip_cap = 1_000_000_000
